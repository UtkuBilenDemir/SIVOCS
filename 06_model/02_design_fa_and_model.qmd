---
title: "[SIVOCS] Factor Analyis and Model Design"
author: ""
date: "5/22/2021"
format: 
  html:
    fig-width: 8
    fig-height: 4
    code-fold: true
---

```{r}
#| echo: false
#| warning: false
#| message: false
#| include: false

library(psych)
library(plotly)
library(lavaan)
library(tidyverse)
library(dplyr)

setwd("../../utku_SIVOCS/")
source("./02_analysis/02_static_responses.R")
source("./02_analysis/99_question_groups.R")
# Load the feature importances from python script
feature_list <- read.csv("./02_analysis/PFA_feature_importance.csv")

```
# 1. Variable Elimination

1.1.  Previously removed variables

```{r}
features_to_rm <- tail(feature_list$X0, 40)
# Qualitatively select the worse performing features
features_to_rm <- features_to_rm[c(22,26,29:40)]
features_to_rm <- c(features_to_rm, 
                    "dissChannels.trad.",
                    "dissChannels.socmed.",
                    "dissChannels.consult.",
                    "dissChannels.events.", 
                    "dissChannels.public.",
                    "concepts.data.",
                    "concepts.code.",
                    "concepts.infra.",
                    "contribToSI.rate.",
                    "groupsInvolved.res.",
                    "natureOfInvolvement.res.",
                    "contribToSI.rate.",
                    "concepts2"
                    )

# remove the weak features
df_red <- feat_df.num_o[, !(colnames(feat_df.num_o ) %in% features_to_rm)]
```

1.2.  We got a number of variables which actually measures the researchers, remove those.

-   Remove the variables from the previous 1. factor
-   Remove bussiness variables -\> useless
-   Remove scalability (measuring something else)

```{r}
## SI Familiarity Factor
factor_1 <- c("familiarWithSI.response.", "transdisciplinaryExp.rate.")
df_red <- df_red %>%
 dplyr::select(-all_of(factor_1))

## MISC:business
factor_busi <- c("groupsInvolved.busi.", "impactTargetGroup.busi.", "kindOfChange.busi.")
df_red <- df_red %>%
  dplyr::select(-all_of(factor_busi))


## MISC:scalability
factor_scale <- c("scalabilityRating.up.", "scalabilityRating.out.", "scalabilityRating.deep.")
df_red <- df_red %>%
  dplyr::select(-all_of(factor_scale))

colnames(df_red)
```

-   Generate a df without the variables including another dimension of observation (researchers instead of projects) to run the FA on

```{r}
df_model <- feat_df.num_o %>%
  dplyr::select(-all_of(c(factor_1, "contribToSI.rate.")))

colnames(df_model)
```
# 2. Factor Analysis

## 2.1. Scree Plot

Determine Number of Factors to Extract

```{r }
library(nFactors)
df_red2 <- df_red[, !colnames(df_red) %in% c("motivation.pheno.")] # Removing this one doesn't change anything
ev <- eigen(cor(df_red2)) # get eigenvalues

ap <- parallel(subject=nrow(df_red2), var=ncol(df_red2),
               rep=1000,cent=.05)
nS <- nScree(x=ev$values, aparallel=ap$eigen$qevpea)
plotnScree(nS)  # 9 Factors

```

The optimal number of factors is 7 (as opposed to 8 in the previous one)

## 2.2. Exploratory Factor Analysis

```{r}
# --- FA explanatory
# Maximum Likelihood Factor Analysis
# entering raw data and extracting 8 factors, 
# with varimax rotation 
fit <- factanal(df_red, 7, rotation="varimax")
print(fit, digits=2, cutoff=.3, sort=TRUE)

```
```{r}
fit$uniquenesses[order(fit$uniquenesses, decreasing = T)]
```
```{r}
library(psych)
library(GPArotation)
fa(df_model, 5)
```

```{r}
library("Hmisc")
res2 <- rcorr(as.matrix(df_red))
res2$r > 0.5
```

```{r}

# Intention
"
motivation.welfare.+
benefitForNonAcademy+
targetGroupsGoals.improve.+
targetGroupsGoals.empower.+
impactTargetGroup.pub.+
impulseForNonAcad.soc.+
targetGroupsGoals.socgroups.+
natureOfInvolvement.civsoc.+

targetGroupsGoals.socneeds.+
targetGroupsGoals.empower.+
targetGroupsGoals.diversity.
"
## Intention-other
"
motivation.pheno.+
motivation.prob.+
impulseForNonAcad.ecol.+
impulseForNonAcad.health.+
impulseForNonAcad.tech.+
impulseForNonAcad.econ. 
"

# Actors

"
groupsInvolved.citiz.+
natureOfInvolvement.citiz.+
groupsInvolved.welfare.+
natureOfInvolvement.welfare.+
impactTargetGroup.welfare.+

groupsInvolved.civsoc.+
natureOfInvolvement.civsoc.+
impactTargetGroup.civsoc.+
kindOfChange.civsoc. 
"


"
kindOfChange.policy.+
impactTargetGroup.policy.+
kindOfChange.pub.+
kindOfChange.socgr.+
kindOfChange.acad. 
kindOfChange.welfare.+
"

"
Impactstatements.capab.+
Impactstatements.emanc.+
Impactstatements.understanding.+
Impactstatements.mitig.+
Impactstatements.unknown.+
Impactstatements.unaddressed.+
impactTargetGroup.socgr. 
"

```



```{r}
model_theory <-"
  ## intention_agency
  ia_human_condition =~ motivation.welfare.+benefitForNonAcademy+impulseForNonAcad.soc.+targetGroupsGoals.improve.+impulseForNonAcad.health.+impulseForNonAcad.ecol.+kindOfChange.pub.+kindOfChange.socgr.+kindOfChange.welfare.+kindOfChange.civsoc.
  
  ia_non_academic =~ impulseForNonAcad.econ.+impulseForNonAcad.tech.
  
  ## transdisciplinary_apects
  transdisciplinary_social =~ groupsInvolved.citiz.+groupsInvolved.civsoc.+groupsInvolved.welfare.+natureOfInvolvement.citiz.+natureOfInvolvement.civsoc.+natureOfInvolvement.welfare.+targetGroupsGoals.socneeds.+targetGroupsGoals.socgroups.+targetGroupsGoals.empower.+targetGroupsGoals.diversity.
  outcome =~ impactTargetGroup.pub.+impactTargetGroup.socgr.+impactTargetGroup.welfare.+impactTargetGroup.civsoc.+Impactstatements.capab.+Impactstatements.emanc.+Impactstatements.understanding.+Impactstatements.mitig.+Impactstatements.unknown.+Impactstatements.unaddressed.
  
  ## MISC:policy
  policy =~ groupsInvolved.policy.+impactTargetGroup.policy.+kindOfChange.policy.+natureOfInvolvement.policy.+groupsInvolved.policy.+adoptByPolicyHow.SQ001."

```

```{r}
model_theory2 <-"
  # SOLUTION ORIENTATION
  ia_human_condition =~ 
  motivation.welfare. + 
  benefitForNonAcademy + 
  impulseForNonAcad.soc. + 
  targetGroupsGoals.improve. 
  
  ia_nonacad_impulse =~ 
  impulseForNonAcad.econ. + 
  impulseForNonAcad.tech. +
  impulseForNonAcad.health. + 
  impulseForNonAcad.ecol. 
  
  
  #  ACTORS & NETWORKS
  transdisciplinary_involvement =~ 
  groupsInvolved.citiz. + 
  groupsInvolved.civsoc. + 
  groupsInvolved.welfare. + 
  natureOfInvolvement.citiz. + 
  natureOfInvolvement.civsoc. + 
  natureOfInvolvement.welfare.
  
  
  transdisciplinary_goals =~ 
  targetGroupsGoals.socneeds. + 
  targetGroupsGoals.socgroups. + 
  targetGroupsGoals.empower. + 
  targetGroupsGoals.diversity.
  
  # NOVELTY 
  innovativeness =~
  kindOfChange.pub. + 
  kindOfChange.socgr. + 
  kindOfChange.welfare. + 
  kindOfChange.civsoc.
  
  
  # OUTCOME
  outcomes =~ 
  impactTargetGroup.pub. + 
  impactTargetGroup.socgr. + 
  impactTargetGroup.welfare. + 
  impactTargetGroup.civsoc. + 
  Impactstatements.capab. + 
  Impactstatements.emanc. + 
  Impactstatements.understanding. + 
  Impactstatements.mitig. + 
  Impactstatements.unknown. + 
  Impactstatements.unaddressed.
  
  # MISC:policy
  policy =~ groupsInvolved.policy.+impactTargetGroup.policy.+kindOfChange.policy.+natureOfInvolvement.policy.+groupsInvolved.policy.+adoptByPolicyHow.SQ001."

```

```{r}
cor(df_fitted$ia_human_condition, df_fitted$outcomes)
```

```{r}
model_theory3 <-"
  # SOLUTION ORIENTATION
  ia_human_condition =~ 
  motivation.welfare. + 
  benefitForNonAcademy + 
  impulseForNonAcad.soc. + 
  targetGroupsGoals.improve. 
  
  ia_nonacad_impulse =~ 
  impulseForNonAcad.econ. + 
  impulseForNonAcad.tech. +
  impulseForNonAcad.health. + 
  impulseForNonAcad.ecol. 
  
  
  #  ACTORS & NETWORKS
  transdisciplinary_involvement =~ 
  groupsInvolved.citiz. + 
  groupsInvolved.civsoc. + 
  groupsInvolved.welfare. + 
  groupsInvolved.policy. +
  natureOfInvolvement.citiz. + 
  natureOfInvolvement.civsoc. + 
  natureOfInvolvement.welfare. +
  natureOfInvolvement.policy.
  
  
  transdisciplinary_goals =~ 
  targetGroupsGoals.socneeds. + 
  targetGroupsGoals.socgroups. + 
  targetGroupsGoals.empower. + 
  targetGroupsGoals.diversity.
  
  # NOVELTY 
  innovativeness =~
  kindOfChange.pub. + 
  kindOfChange.socgr. + 
  kindOfChange.welfare. + 
  kindOfChange.civsoc. +
  kindOfChange.policy.
  
  
  # OUTCOME
  outcome =~ 
  impactTargetGroup.pub. + 
  impactTargetGroup.socgr. + 
  impactTargetGroup.welfare. + 
  impactTargetGroup.civsoc. + 
  impactTargetGroup.policy. +
  Impactstatements.capab. + 
  Impactstatements.emanc. + 
  Impactstatements.understanding. + 
  Impactstatements.mitig. + 
  Impactstatements.unknown. + 
  Impactstatements.unaddressed. +
  adoptByPolicyHow.SQ001.
"
```

###  2.3.1. Conf. Factor analysis: Model 1

```{r}
fit_theory <- cfa(model_theory, df_model)
summary(fit_theory, fit.measures = T, standardized = T)
```

```{r}
modificationindices(fit_theory) %>%
  arrange(-mi) %>%
  head(10)
```



### 2.3.2. Conf. Factor analysis: Model 2

```{r}
fit_theory2 <- cfa(model_theory2, df_model)
# Scale using latent variable variance rather than the first factor loading
fit_theory2b <- cfa(model_theory2, df_model, std.lv = T)
summary(fit_theory2, fit.measures = T, standardized = T)
```

```{r}
modificationindices(fit_theory2) %>%
  arrange(-mi) %>%
  head(10)
```

### 2.3.3. Conf. Factor analysis: Model 3

```{r}
fit_theory3 <- cfa(model_theory3, df_model)
summary(fit_theory3, fit.measures = T, standardized = T)
```

```{r}
modificationindices(fit_theory3) %>%
  arrange(-mi) %>%
  head(10)
```

## 2.4. CFA Model Comparison

```{r}
anova(
  fit_theory
  , fit_theory2
  , fit_theory2b
  , fit_theory3
  )
```

`fit_theory2` performs significantly better than the others

```{r}
parameterestimates(fit_theory2b)
```

```{r}
fitmeasures(fit_theory3)
```

## 2.5. Fitting data into the FA model

```{r}
library(scales)
df_fitted <- data.frame(predict(fit_theory2b))
# -> Scale all the variables from 0 to 10
df_fitted <- df_fitted %>%
  sapply(rescale, c(0, 10)) %>%
  round(digits = 2) %>%
  as.data.frame()

# fit_theory2b
```

# 4. Metadata Analysis through fitted data

# 5. Simple Models

## 5.1. Linear Regression: Concrete Outcome as DV

```{r}
plot(df_fitted)
```

Factors seem to be in linear relationships against each other.

```{r}
lm_fitted <- lm(outcomes ~ 
     ia_human_condition + 
     ia_nonacad_impulse +
     transdisciplinary_involvement +
     transdisciplinary_goals +
     innovativeness +
     policy,
   df_fitted
     )
summary(lm_fitted)
```

Regression model fits relatively well:

-   Adjusted R-squared high, p-value extremely small
-   The dominant IDVs in the model are transdisciplinary goals, innovativeness and in general policy involvement. Trans. involvement has also a small p-value but only limited influence in the concrete outcomes.

```{r}
library(modelr)
library(ggplot2)

lm_grid <- df_fitted %>% 
  data_grid(ia_human_condition, .model = lm_fitted) %>% 
  add_predictions(lm_fitted)
lm_grid
ggplot(lm_grid, aes(ia_human_condition, pred)) + 
  geom_point()
```


## 5.1.1. Create an SI-Index and test against it

```{r}
si_index <- rowMeans(df_fitted)
lm_index_fitted <- lm(si_index ~
     outcomes +
     ia_human_condition + 
     ia_nonacad_impulse +
     transdisciplinary_involvement +
     transdisciplinary_goals +
     innovativeness +
     policy,
   df_fitted
     )
summary(lm_index_fitted)
```

Testing against a self-induced index doesn't help much

# 6. Complex Modelling approaches

## 6.1. Ordinal logistic regression

-   Split dataframe into test and train

```{r}
# Split into 2 groups
inds <- sample(2, nrow(df_fitted), replace = T, prob = c(0.8, 0.2))
train <- df_fitted[inds == 1, ]
test <- df_fitted[inds == 2, ]

```

-   Apply ordinal logistic regression or proportional odds logistic regression

```{r}
library(MASS)
colnames(df_fitted)
ord_log_model <- polr(
  as.factor(outcomes) ~ 
    ia_human_condition + 
    ia_nonacad_impulse +
    transdisciplinary_involvement +
    transdisciplinary_goals +
    innovativeness +
    policy,
  train,
  Hess = T
  )
summary(ord_log_model)
```

-   LRM p-values

```{r}
(ctable <- coef(summary(ord_log_model)))
p <- pnorm(abs(ctable[, "t value"]), lower.tail = F) * 2
(ctable <- cbind("p value" = p))
```

```{r}
train[1:5, "outcomes"]
```

```{r}
pred <- predict(ord_log_model, train[1:5, ], type = "prob")
print(pred, digits = 2)
colnames(pred)[apply(pred, 1,which.max)]
```

```{r}
test[1:5, "outcomes"]
```

```{r}
pred2 <- predict(ord_log_model, test[1:5, ], type = "prob")
print(pred2, digits = 2)
colnames(pred2)[apply(pred2, 1,which.max)]
```

-   Confusion Matrix

```{r}
pred3 <- predict(ord_log_model, train)
(tab <- table(pred3, train$outcomes))
1- sum(diag(tab))/sum(tab)
babap <- as.data.frame(tab)
```

```{r}
pred4 <- predict(ord_log_model, test)
(tab1 <- table(pred4, test$outcomes))
1- sum(diag(tab1))/sum(tab1)
## babap <- as.data.frame(tab1)
```
